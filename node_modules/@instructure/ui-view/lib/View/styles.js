"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _uiI18n = require("@instructure/ui-i18n");
var _emotion = require("@instructure/emotion");
var _pickProps = require("@instructure/ui-react-utils/lib/pickProps.js");
var _alpha = require("@instructure/ui-color-utils/lib/alpha.js");
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

const getBorderStyle = ({
  borderRadius,
  borderWidth,
  dir,
  theme
}) => {
  const isRtlDirection = dir === _uiI18n.DIRECTION.rtl;
  return {
    borderRadius: (0, _emotion.getShorthandPropValue)('View', theme, isRtlDirection ? (0, _emotion.mirrorShorthandCorners)(borderRadius) : borderRadius, 'borderRadius', true),
    borderWidth: (0, _emotion.getShorthandPropValue)('View', theme, isRtlDirection ? (0, _emotion.mirrorShorthandEdges)(borderWidth) : borderWidth, 'borderWidth')
  };
};
const getSpacingStyle = ({
  margin,
  padding,
  dir,
  theme
}) => {
  const isRtlDirection = dir === _uiI18n.DIRECTION.rtl;
  return {
    margin: (0, _emotion.getShorthandPropValue)('View', theme, isRtlDirection ? (0, _emotion.mirrorShorthandEdges)(margin) : margin, 'margin'),
    padding: (0, _emotion.getShorthandPropValue)('View', theme, isRtlDirection ? (0, _emotion.mirrorShorthandEdges)(padding) : padding, 'padding')
  };
};
const getOffsetStyle = ({
  insetBlockStart,
  insetBlockEnd,
  insetInlineStart,
  insetInlineEnd,
  dir
}) => {
  const isRtlDirection = dir === _uiI18n.DIRECTION.rtl;
  const blockStart = {
    top: insetBlockStart,
    insetBlockStart
  };
  const blockEnd = {
    bottom: insetBlockEnd,
    insetBlockEnd
  };
  const horizontalOffsets = {
    left: isRtlDirection ? insetInlineEnd : insetInlineStart,
    right: isRtlDirection ? insetInlineStart : insetInlineEnd
  };
  return {
    ...blockStart,
    ...blockEnd,
    ...horizontalOffsets
  };
};
const getStyleProps = ({
  cursor,
  style
}) => {
  const whitelisted = (0, _pickProps.pickProps)(style || {}, {}, [
  // Position/calculateElementPosition:
  'top', 'left', 'position', 'display', 'transform', 'overflow', 'minWidth', 'minHeight',
  // Img:
  'filter',
  // Flex.Item:
  'flexBasis',
  // Avatar:
  'backgroundImage',
  // Popover:
  'pointerEvents']);
  if (cursor) {
    whitelisted.cursor = cursor;
  }
  return whitelisted;
};
const withBorder = props => {
  const borderWidth = props.borderWidth;
  return borderWidth && borderWidth !== '0' && borderWidth !== 'none';
};
const getFocusStyles = (props, componentTheme) => {
  const focusColor = props.focusColor,
    focusPosition = props.focusPosition,
    shouldAnimateFocus = props.shouldAnimateFocus,
    withFocusOutline = props.withFocusOutline,
    focusWithin = props.focusWithin;
  const focusPos = focusPosition == 'offset' || focusPosition == 'inset' ? focusPosition : 'offset';
  const focusPositionVariants = {
    offset: {
      outlineOffset: `calc(${componentTheme.focusOutlineOffset} - ${componentTheme.focusOutlineWidth})`
    },
    inset: {
      outlineOffset: `calc(${componentTheme.focusOutlineInset} - ${componentTheme.focusOutlineWidth})`
    }
  };
  const focusColorVariants = {
    info: componentTheme.focusColorInfo,
    inverse: componentTheme.focusColorInverse,
    success: componentTheme.focusColorSuccess,
    danger: componentTheme.focusColorDanger
  };
  const visibleFocusStyle = {
    ...focusPositionVariants[focusPos],
    outlineColor: focusColorVariants[focusColor]
  };
  const outlineStyle = {
    outlineOffset: '-0.8rem',
    // value when not in focus, its invisible
    outlineColor: (0, _alpha.alpha)(focusColorVariants[focusColor], 0),
    outlineStyle: componentTheme.focusOutlineStyle,
    outlineWidth: componentTheme.focusOutlineWidth,
    ...(withFocusOutline && visibleFocusStyle)
  };
  return {
    ...(shouldAnimateFocus && {
      transition: 'outline-color 0.2s, outline-offset 0.25s'
    }),
    ...outlineStyle,
    '&:hover, &:active': {
      // apply the same style so it's not overridden by some global style
      ...outlineStyle
    },
    ...(typeof withFocusOutline === 'undefined' && {
      // user focuses the element
      '&:focus': visibleFocusStyle
    }),
    ...(focusWithin && {
      '&:focus-within': visibleFocusStyle
    })
  };
};

/**
 * Generates the style object from the theme and provided additional information
 * @param  {Object} componentTheme The theme variable object.
 * @param  {Object} props the props of the component, the style is applied to
 * @return {Object} The final style object, which will be used in the component
 */
const generateStyle = (componentTheme, props) => {
  const borderRadius = props.borderRadius,
    borderWidth = props.borderWidth,
    margin = props.margin,
    padding = props.padding,
    position = props.position,
    display = props.display,
    textAlign = props.textAlign,
    borderColor = props.borderColor,
    background = props.background,
    stacking = props.stacking,
    shadow = props.shadow,
    overflowY = props.overflowY,
    overflowX = props.overflowX,
    overscrollBehavior = props.overscrollBehavior,
    insetBlockEnd = props.insetBlockEnd,
    insetBlockStart = props.insetBlockStart,
    insetInlineEnd = props.insetInlineEnd,
    insetInlineStart = props.insetInlineStart,
    width = props.width,
    height = props.height,
    minWidth = props.minWidth,
    minHeight = props.minHeight,
    maxWidth = props.maxWidth,
    maxHeight = props.maxHeight,
    withVisualDebug = props.withVisualDebug,
    dir = props.dir;
  const borderStyle = getBorderStyle({
    theme: componentTheme,
    borderRadius,
    borderWidth,
    dir
  });
  const spacingStyle = getSpacingStyle({
    margin,
    padding,
    theme: componentTheme,
    dir
  });
  const offsetStyle = getOffsetStyle({
    dir,
    insetBlockEnd,
    insetBlockStart,
    insetInlineEnd,
    insetInlineStart
  });
  const displayVariants = {
    inline: {
      label: 'view--inline',
      display: 'inline'
    },
    block: {
      label: 'view--block',
      display: 'block'
    },
    'inline-block': {
      label: 'view--inlineBlock',
      display: 'inline-block',
      verticalAlign: 'middle'
    },
    flex: {
      label: 'view--flex',
      display: 'flex'
    },
    'inline-flex': {
      label: 'view--inlineFlex',
      display: 'inline-flex',
      verticalAlign: 'middle'
    },
    auto: {}
  };
  const textAlignVariants = {
    start: {
      textAlign: 'start'
    },
    center: {
      textAlign: 'center'
    },
    end: {
      textAlign: 'end'
    }
  };
  const borderColorVariants = {
    transparent: {
      borderColor: componentTheme.borderColorTransparent
    },
    primary: {
      borderColor: componentTheme.borderColorPrimary
    },
    secondary: {
      borderColor: componentTheme.borderColorSecondary
    },
    brand: {
      borderColor: componentTheme.borderColorBrand
    },
    info: {
      borderColor: componentTheme.borderColorInfo
    },
    success: {
      borderColor: componentTheme.borderColorSuccess
    },
    warning: {
      borderColor: componentTheme.borderColorWarning
    },
    alert: {
      borderColor: componentTheme.borderColorAlert
    },
    danger: {
      borderColor: componentTheme.borderColorDanger
    }
  };
  const backgroundColorVariants = {
    transparent: {
      color: componentTheme.color,
      background: 'none'
    },
    primary: {
      color: componentTheme.color,
      background: componentTheme.backgroundPrimary
    },
    secondary: {
      color: componentTheme.color,
      background: componentTheme.backgroundSecondary
    },
    ['primary-inverse']: {
      color: componentTheme.colorPrimaryInverse,
      background: componentTheme.backgroundPrimaryInverse
    },
    brand: {
      color: componentTheme.colorPrimaryInverse,
      background: componentTheme.backgroundBrand
    },
    info: {
      color: componentTheme.colorPrimaryInverse,
      background: componentTheme.backgroundInfo
    },
    alert: {
      color: componentTheme.colorPrimaryInverse,
      background: componentTheme.backgroundAlert
    },
    success: {
      color: componentTheme.colorPrimaryInverse,
      background: componentTheme.backgroundSuccess
    },
    danger: {
      color: componentTheme.colorPrimaryInverse,
      background: componentTheme.backgroundDanger
    },
    warning: {
      color: componentTheme.colorPrimaryInverse,
      background: componentTheme.backgroundWarning
    }
  };
  const stackingVariants = {
    topmost: {
      zIndex: componentTheme.stackingTopmost
    },
    above: {
      zIndex: componentTheme.stackingAbove
    },
    resting: {},
    below: {
      zIndex: componentTheme.stackingBelow
    },
    deepest: {
      zIndex: componentTheme.stackingDeepest
    }
  };
  const shadowVariants = {
    topmost: {
      boxShadow: componentTheme.shadowTopmost
    },
    resting: {
      boxShadow: componentTheme.shadowResting
    },
    above: {
      boxShadow: componentTheme.shadowAbove
    },
    none: {}
  };
  const focusStyles = getFocusStyles(props, componentTheme);
  return {
    view: {
      label: 'view',
      boxSizing: 'border-box',
      fontFamily: componentTheme.fontFamily,
      maxWidth: '100%',
      overflow: 'visible',
      ...displayVariants[display],
      ...(background && backgroundColorVariants[background]),
      ...(stacking && stackingVariants[stacking]),
      ...(shadow && shadowVariants[shadow]),
      ...(textAlign && textAlignVariants[textAlign]),
      overflowX: overflowX && overflowX !== 'visible' ? overflowX : '',
      overflowY: overflowY && overflowY !== 'visible' ? overflowY : '',
      position: position !== 'static' ? position : '',
      overscrollBehavior: overscrollBehavior ? overscrollBehavior : 'auto',
      ...(withVisualDebug ? {
        boxShadow: `0 0 0 1px ${componentTheme.debugOutlineColor}`
      } : {}),
      ...(withBorder(props) ? {
        borderStyle: componentTheme.borderStyle,
        ...(borderColorVariants[borderColor] || {
          borderColor: borderColor
        })
      } : {}),
      ...borderStyle
    },
    inlineStyles: {
      //every '&' symbol will add another class to the rule, so it will be stronger
      //making an accidental override less likely
      '&&&&&&&&&&': {
        ...spacingStyle,
        ...offsetStyle,
        ...focusStyles,
        width,
        height,
        minWidth,
        minHeight,
        maxWidth,
        maxHeight,
        ...getStyleProps(props)
      }
    }
  };
};
var _default = exports.default = generateStyle;