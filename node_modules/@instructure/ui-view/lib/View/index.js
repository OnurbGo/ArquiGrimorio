"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.View = void 0;
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _react = require("react");
var _getComputedStyle = require("@instructure/ui-dom-utils/lib/getComputedStyle.js");
var _textDirectionContextConsumer = require("@instructure/ui-i18n/lib/textDirectionContextConsumer.js");
var _console = require("@instructure/console");
var _getElementType = require("@instructure/ui-react-utils/lib/getElementType.js");
var _omitProps = require("@instructure/ui-react-utils/lib/omitProps.js");
var _pickProps = require("@instructure/ui-react-utils/lib/pickProps.js");
var _passthroughProps = require("@instructure/ui-react-utils/lib/passthroughProps.js");
var _emotion = require("@instructure/emotion");
var _styles = _interopRequireDefault(require("./styles"));
var _theme = _interopRequireDefault(require("./theme"));
var _props = require("./props");
var _jsxRuntime = require("@emotion/react/jsx-runtime");
const _excluded = ["children", "textAlign", "background", "display", "withVisualDebug", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "overflowX", "overflowY", "stacking", "shadow", "position", "focusPosition", "focusColor", "shouldAnimateFocus", "borderColor", "className", "overscrollBehavior", "styles", "makeStyles"];
var _dec, _dec2, _class, _View;
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 - present Instructure, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/**
---
category: components
---
@module View
**/
let View = exports.View = (_dec = (0, _textDirectionContextConsumer.textDirectionContextConsumer)(), _dec2 = (0, _emotion.withStyle)(_styles.default, _theme.default), _dec(_class = _dec2(_class = (_View = class View extends _react.Component {
  get _element() {
    return this.ref;
  }
  constructor(props) {
    super(props);
    this.spanMarginVerified = void 0;
    this.ref = null;
    this.handleElementRef = el => {
      if (typeof this.props.elementRef === 'function') {
        this.props.elementRef(el);
      }
      this.ref = el;
    };
    this.spanMarginVerified = false;
  }
  componentDidMount() {
    var _this$props$makeStyle, _this$props;
    (_this$props$makeStyle = (_this$props = this.props).makeStyles) === null || _this$props$makeStyle === void 0 ? void 0 : _this$props$makeStyle.call(_this$props);
  }
  componentDidUpdate() {
    var _this$props$makeStyle2, _this$props2;
    (_this$props$makeStyle2 = (_this$props2 = this.props).makeStyles) === null || _this$props$makeStyle2 === void 0 ? void 0 : _this$props$makeStyle2.call(_this$props2);

    // Not calling getComputedStyle can save hundreds of ms in tests and production
    if (process.env.NODE_ENV === 'development' && !this.spanMarginVerified) {
      // We have to verify margins in the first 'componentDidUpdate',
      // because that is when all styles are calculated,
      // but we only want to check once, using a flag
      this.spanMarginVerified = true;
      (0, _console.logError)(!function verifySpanMargin(element, margin) {
        if (!element) {
          return;
        }
        const display = (0, _getComputedStyle.getComputedStyle)(element).display;
        if (display !== 'inline') {
          return;
        }
        const marginValues = margin ? margin.split(' ') : null;
        let verticalMargin = false;

        // either top or bottom margin are set
        if (margin) {
          if (marginValues && marginValues[0] && marginValues[0] !== 'none' && marginValues[0] !== '0') {
            verticalMargin = true;
          }
          if (marginValues && marginValues[2] && marginValues[2] !== 'none' && marginValues[2] !== '0') {
            verticalMargin = true;
          }
        }
        return verticalMargin;
      }(this.ref, this.props.margin), `[View] display style is set to 'inline' and will allow for horizontal margins only.`);
    }
  }
  render() {
    const _this$props3 = this.props,
      children = _this$props3.children,
      textAlign = _this$props3.textAlign,
      background = _this$props3.background,
      display = _this$props3.display,
      withVisualDebug = _this$props3.withVisualDebug,
      width = _this$props3.width,
      height = _this$props3.height,
      minWidth = _this$props3.minWidth,
      minHeight = _this$props3.minHeight,
      maxWidth = _this$props3.maxWidth,
      maxHeight = _this$props3.maxHeight,
      overflowX = _this$props3.overflowX,
      overflowY = _this$props3.overflowY,
      stacking = _this$props3.stacking,
      shadow = _this$props3.shadow,
      position = _this$props3.position,
      focusPosition = _this$props3.focusPosition,
      focusColor = _this$props3.focusColor,
      shouldAnimateFocus = _this$props3.shouldAnimateFocus,
      borderColor = _this$props3.borderColor,
      className = _this$props3.className,
      overscrollBehavior = _this$props3.overscrollBehavior,
      styles = _this$props3.styles,
      makeStyles = _this$props3.makeStyles,
      props = (0, _objectWithoutProperties2.default)(_this$props3, _excluded);
    const ElementType = (0, _getElementType.getElementType)(View, this.props);
    return (0, _jsxRuntime.jsx)(ElementType, {
      ...(0, _passthroughProps.passthroughProps)(props),
      className: className,
      css: [styles === null || styles === void 0 ? void 0 : styles.view, styles === null || styles === void 0 ? void 0 : styles.inlineStyles],
      ref: this.handleElementRef,
      children: children
    });
  }
}, _View.displayName = "View", _View.componentId = 'View', _View.allowedProps = _props.allowedProps, _View.propTypes = _props.propTypes, _View.defaultProps = {
  display: 'auto',
  overflowX: 'visible',
  overflowY: 'visible',
  withVisualDebug: false,
  borderColor: 'primary',
  position: 'static',
  focusPosition: 'offset',
  focusColor: 'info',
  shouldAnimateFocus: true,
  overscrollBehavior: 'auto'
}, _View.omitViewProps = (props, Component) => {
  // We don't want the theming and styling props to pass
  // (these are added and handled by the `@withStyle` decorator)
  const propsToOmit = [..._View.allowedProps, 'styles', 'makeStyles', 'themeOverride'];
  let shouldLogError = true;
  try {
    shouldLogError = process.env.NODE_ENV !== 'production';
  } catch (e) {
    if (e instanceof ReferenceError) {
      // if process is not available a ReferenceError is thrown
      shouldLogError = false;
    } else {
      throw e;
    }
  }
  if (shouldLogError) {
    Object.keys((0, _pickProps.pickProps)(props, propsToOmit)).forEach(prop => {
      (0, _console.logError)(false, `[${Component.name}] prop '${prop}' is not allowed.`);
    });
  }
  return (0, _omitProps.omitProps)(props, propsToOmit);
}, _View)) || _class) || _class);
var _default = exports.default = View;